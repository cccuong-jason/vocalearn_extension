{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sBAAsB,GAAG,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5B4E;AACA;AACI;AACG;AACW;AACA;AACW;AAClG;AACP;AACA;AACA;AACA,oCAAoC,oFAAqB;AACzD,mCAAmC,oFAAqB;AACxD,gCAAgC,wFAAuB;AACvD,8BAA8B,2FAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mGAAoB;AACvC;AACA;AACA,mBAAmB,mGAAoB;AACvC;AACA;AACA,mBAAmB,8GAAyB;AAC5C;AACA;;;;;;;;;;;;;;;;;;ACzC4E;AACrB;AACvD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AAClD;AACP;AACA;AACA;AACA,2BAA2B,oFAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oFAAqB;AAChD;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA;;;;;;;;;;;;;;;;AChCA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAU;AACtB;AACA,8BAA8B,yCAAyC;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,+DAAU,qBAAqB,mBAAmB;AAC9D;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,YAAY,+DAAU,qBAAqB,4BAA4B;AACvE;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC/CO;AACP;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,GAAG,yBAAyB;AACrF;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;;;;;;;;;;;;;;AClDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oCAAoC;AAC9G,wDAAwD,eAAe;AACvE,kEAAkE,eAAe;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C,kBAAkB,6BAA6B;AAC/C,kBAAkB,4BAA4B;AAC9C,kBAAkB,4BAA4B;AAC9C,kBAAkB,6BAA6B;AAC/C,kBAAkB,gCAAgC;AAClD,kBAAkB,6BAA6B;AAC/C,kBAAkB,6BAA6B;AAC/C,kBAAkB;AAClB;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,GAAG,yBAAyB;AACrF;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oCAAoC;AAC9G,wDAAwD,eAAe;AACvE,kEAAkE,eAAe;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9RO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;UCJ1B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNA;AACkD;AACU;AACkB;AACY;AACnF;AACP;AACA;AACA;AACA,IAAI,+DAAU;AACd,QAAQ,+DAAU;AAClB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,IAAI,+DAAU;AACd;AACA,YAAY,+DAAU;AACtB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,IAAI,+DAAU;AACd;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,uFAAoB;AAC9C;AACA;AACA;AACA,QAAQ,+DAAU;AAClB;AACA,SAAS;AACT,KAAK;AACL,IAAI,mGAAyB;AAC7B;AACA;AACA;AACA,8BAA8B,uFAAoB;AAClD;AACA,+BAA+B,qEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA,+BAA+B,qEAAc;AAC7C;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,sCAAsC;AAC7D;AACA;AACA;AACA","sources":["webpack://vocalearn-extension/./src/core/application/usecases/get-definition-usecase.ts","webpack://vocalearn-extension/./src/core/application/usecases/save-vocabulary-word-usecase.ts","webpack://vocalearn-extension/./src/core/application/usecases/translate-text-usecase.ts","webpack://vocalearn-extension/./src/infra/di/service-locator.ts","webpack://vocalearn-extension/./src/infra/factories/translation-service-factory.ts","webpack://vocalearn-extension/./src/infra/services/configuration-service.ts","webpack://vocalearn-extension/./src/infra/services/free-dictionary-service.ts","webpack://vocalearn-extension/./src/infra/services/indexeddb-storage-service.ts","webpack://vocalearn-extension/./src/infra/services/libre-translate-service.ts","webpack://vocalearn-extension/./src/infra/services/local-storage-cache-service.ts","webpack://vocalearn-extension/./src/utils/browser-polyfill.ts","webpack://vocalearn-extension/webpack/bootstrap","webpack://vocalearn-extension/webpack/runtime/define property getters","webpack://vocalearn-extension/webpack/runtime/hasOwnProperty shorthand","webpack://vocalearn-extension/webpack/runtime/make namespace object","webpack://vocalearn-extension/./src/background.ts"],"sourcesContent":["export class GetDefinitionUseCase {\n    constructor(dictionaryService, cacheService) {\n        this.dictionaryService = dictionaryService;\n        this.cacheService = cacheService;\n    }\n    async execute(word) {\n        // Check cache first\n        const cacheKey = `definition_${word}`;\n        const cachedDefinition = await this.cacheService.get(cacheKey);\n        if (cachedDefinition) {\n            return cachedDefinition;\n        }\n        // Get fresh definition\n        try {\n            const definition = await this.dictionaryService.getDefinition(word);\n            if (definition) {\n                // Cache the result\n                await this.cacheService.set(cacheKey, definition, 604800); // 7 days TTL\n            }\n            return definition;\n        }\n        catch (error) {\n            console.error('Error fetching definition:', error);\n            return null;\n        }\n    }\n}\n","export class SaveVocabularyWordUseCase {\n    constructor(storageService) {\n        this.storageService = storageService;\n    }\n    async execute(word, translation, notes = '') {\n        const vocabWord = {\n            word,\n            translation,\n            notes,\n            dateAdded: new Date().toISOString(),\n            lastReviewed: new Date().toISOString()\n        };\n        return this.storageService.saveWord(vocabWord);\n    }\n}\n","export class TranslateTextUseCase {\n    constructor(translationService, cacheService) {\n        this.translationService = translationService;\n        this.cacheService = cacheService;\n    }\n    async execute(text, targetLanguages) {\n        const result = {};\n        for (const lang of targetLanguages) {\n            // Check cache first\n            const cacheKey = `translation_${text.substring(0, 50)}_${lang}`;\n            const cachedTranslation = await this.cacheService.get(cacheKey);\n            if (cachedTranslation) {\n                result[lang] = cachedTranslation.translatedText;\n                continue;\n            }\n            // Get fresh translation\n            try {\n                const translation = await this.translationService.translateText(text, lang);\n                result[lang] = translation.translatedText;\n                // Cache the result\n                await this.cacheService.set(cacheKey, translation, 86400); // 24 hours TTL\n            }\n            catch (error) {\n                console.error(`Error translating to ${lang}:`, error);\n            }\n        }\n        return result;\n    }\n}\n","import { LibreTranslateService } from '../services/libre-translate-service';\nimport { FreeDictionaryService } from '../services/free-dictionary-service';\nimport { IndexedDBStorageService } from '../services/indexeddb-storage-service';\nimport { LocalStorageCacheService } from '../services/local-storage-cache-service';\nimport { TranslateTextUseCase } from '../../core/application/usecases/translate-text-usecase';\nimport { GetDefinitionUseCase } from '../../core/application/usecases/get-definition-usecase';\nimport { SaveVocabularyWordUseCase } from '../../core/application/usecases/save-vocabulary-word-usecase';\nexport class ServiceLocator {\n    constructor() {\n        // Initialize with default implementations\n        this.services = {\n            translationService: new LibreTranslateService(),\n            dictionaryService: new FreeDictionaryService(),\n            storageService: new IndexedDBStorageService(),\n            cacheService: new LocalStorageCacheService()\n        };\n    }\n    static getInstance() {\n        if (!ServiceLocator.instance) {\n            ServiceLocator.instance = new ServiceLocator();\n        }\n        return ServiceLocator.instance;\n    }\n    // Get a service by its type\n    getService(serviceName) {\n        return this.services[serviceName];\n    }\n    // Register a new service implementation\n    registerService(serviceName, implementation) {\n        this.services[serviceName] = implementation;\n    }\n    // Get use cases with proper dependencies\n    getTranslateTextUseCase() {\n        return new TranslateTextUseCase(this.services.translationService, this.services.cacheService);\n    }\n    getDefinitionUseCase() {\n        return new GetDefinitionUseCase(this.services.dictionaryService, this.services.cacheService);\n    }\n    getSaveVocabularyWordUseCase() {\n        return new SaveVocabularyWordUseCase(this.services.storageService);\n    }\n}\n","import { LibreTranslateService } from '../services/libre-translate-service';\nimport { ServiceLocator } from '../di/service-locator';\n// Add more implementations as needed\nexport var TranslationServiceType;\n(function (TranslationServiceType) {\n    TranslationServiceType[\"LIBRE_TRANSLATE\"] = \"libre_translate\";\n    TranslationServiceType[\"GOOGLE_TRANSLATE\"] = \"google_translate\";\n    TranslationServiceType[\"MICROSOFT_TRANSLATE\"] = \"microsoft_translate\";\n    TranslationServiceType[\"DEEPL\"] = \"deepl\";\n})(TranslationServiceType || (TranslationServiceType = {}));\nexport class TranslationServiceFactory {\n    static create(type, apiKey) {\n        switch (type) {\n            case TranslationServiceType.LIBRE_TRANSLATE:\n                return new LibreTranslateService();\n            // Add more implementations as needed\n            /*\n            case TranslationServiceType.GOOGLE_TRANSLATE:\n              return new GoogleTranslateService(apiKey);\n            case TranslationServiceType.MICROSOFT_TRANSLATE:\n              return new MicrosoftTranslateService(apiKey);\n            case TranslationServiceType.DEEPL:\n              return new DeepLTranslateService(apiKey);\n            */\n            default:\n                return new LibreTranslateService();\n        }\n    }\n    static register(type, apiKey) {\n        const service = this.create(type, apiKey);\n        ServiceLocator.getInstance().registerService('translationService', service);\n    }\n}\n","// src/infrastructure/services/configuration-service.ts\nimport browserAPI from '../../utils/browser-polyfill';\nexport class ConfigurationService {\n    constructor() {\n        this.defaultConfig = {\n            targetLanguages: ['es', 'fr', 'de'],\n            autoPopup: true,\n            includeDefinitions: true,\n            translationService: 'libre_translate',\n            dictionaryService: 'free_dictionary',\n            theme: 'system'\n        };\n    }\n    static getInstance() {\n        if (!ConfigurationService.instance) {\n            ConfigurationService.instance = new ConfigurationService();\n        }\n        return ConfigurationService.instance;\n    }\n    async getConfig() {\n        return new Promise((resolve) => {\n            browserAPI.storage.local.get(['config'], (result) => {\n                if (result.config) {\n                    resolve({ ...this.defaultConfig, ...result.config });\n                }\n                else {\n                    resolve(this.defaultConfig);\n                }\n            });\n        });\n    }\n    async updateConfig(config) {\n        const currentConfig = await this.getConfig();\n        const newConfig = { ...currentConfig, ...config };\n        return new Promise((resolve) => {\n            browserAPI.storage.local.set({ config: newConfig }, () => {\n                resolve(newConfig);\n            });\n        });\n    }\n    async resetConfig() {\n        return new Promise((resolve) => {\n            browserAPI.storage.local.set({ config: this.defaultConfig }, () => {\n                resolve(this.defaultConfig);\n            });\n        });\n    }\n}\n","export class FreeDictionaryService {\n    constructor() {\n        this.API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en';\n    }\n    async getDefinition(word) {\n        try {\n            const response = await fetch(`${this.API_URL}/${encodeURIComponent(word)}`);\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null; // Word not found\n                }\n                throw new Error('Dictionary API error');\n            }\n            const data = await response.json();\n            if (!data || !data[0]) {\n                return null;\n            }\n            // Process and format the definition data\n            const result = {\n                word: data[0].word,\n                phonetic: data[0].phonetic || '',\n                meanings: []\n            };\n            // Extract meanings, definitions and examples\n            if (data[0].meanings && data[0].meanings.length > 0) {\n                data[0].meanings.forEach((meaning) => {\n                    const meaningObj = {\n                        partOfSpeech: meaning.partOfSpeech,\n                        definitions: []\n                    };\n                    meaning.definitions.forEach((def) => {\n                        meaningObj.definitions.push({\n                            definition: def.definition,\n                            example: def.example || '',\n                            synonyms: def.synonyms || []\n                        });\n                    });\n                    result.meanings.push(meaningObj);\n                });\n            }\n            return result;\n        }\n        catch (error) {\n            console.error('Error fetching definition:', error);\n            return null;\n        }\n    }\n    getSupportedLanguages() {\n        return ['en']; // Only English is supported\n    }\n}\n","export class IndexedDBStorageService {\n    constructor() {\n        this.DB_NAME = 'vocalearn';\n        this.DB_VERSION = 1;\n        this.STORE_NAME = 'vocabulary';\n    }\n    async initDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onerror = (event) => {\n                reject('IndexedDB error: ' + event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Create object store for vocabulary words\n                if (!db.objectStoreNames.contains(this.STORE_NAME)) {\n                    const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id', autoIncrement: true });\n                    store.createIndex('word', 'word', { unique: false });\n                    store.createIndex('dateAdded', 'dateAdded', { unique: false });\n                }\n            };\n        });\n    }\n    async saveWord(word) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            // Check if word already exists (if it has an ID)\n            const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(this.STORE_NAME);\n            if (word.id) {\n                // Update existing word\n                const updateRequest = store.put(word);\n                updateRequest.onsuccess = () => {\n                    resolve(word);\n                };\n                updateRequest.onerror = () => {\n                    reject(new Error('Error updating word'));\n                };\n            }\n            else {\n                // Check if the word text already exists\n                const wordIndex = store.index('word');\n                const request = wordIndex.getAll(word.word);\n                request.onsuccess = (event) => {\n                    const matches = event.target.result;\n                    if (matches.length > 0) {\n                        // Update existing word\n                        const existingWord = matches[0];\n                        const updatedWord = {\n                            ...existingWord,\n                            translation: word.translation,\n                            notes: word.notes,\n                            lastReviewed: new Date().toISOString()\n                        };\n                        const updateRequest = store.put(updatedWord);\n                        updateRequest.onsuccess = () => {\n                            resolve(updatedWord);\n                        };\n                        updateRequest.onerror = () => {\n                            reject(new Error('Error updating word'));\n                        };\n                    }\n                    else {\n                        // Add new word\n                        const addRequest = store.add(word);\n                        addRequest.onsuccess = (event) => {\n                            const newWord = { ...word, id: event.target.result };\n                            resolve(newWord);\n                        };\n                        addRequest.onerror = () => {\n                            reject(new Error('Error adding word'));\n                        };\n                    }\n                };\n            }\n        });\n    }\n    async getWords() {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readonly');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.getAll();\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Error fetching words'));\n            };\n        });\n    }\n    async getWordById(id) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readonly');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.get(id);\n            request.onsuccess = (event) => {\n                const result = event.target.result;\n                resolve(result || null);\n            };\n            request.onerror = () => {\n                reject(new Error('Error fetching word'));\n            };\n        });\n    }\n    async deleteWord(id) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.delete(id);\n            request.onsuccess = () => {\n                resolve(true);\n            };\n            request.onerror = () => {\n                reject(new Error('Error deleting word'));\n            };\n        });\n    }\n    async searchWords(query) {\n        const words = await this.getWords();\n        const lowerQuery = query.toLowerCase();\n        return words.filter(word => word.word.toLowerCase().includes(lowerQuery) ||\n            word.translation.toLowerCase().includes(lowerQuery) ||\n            word.notes.toLowerCase().includes(lowerQuery));\n    }\n}\n","export class LibreTranslateService {\n    constructor() {\n        this.API_URL = 'https://libretranslate.de';\n        this.supportedLanguages = [];\n        this.loadSupportedLanguages();\n    }\n    async loadSupportedLanguages() {\n        try {\n            const response = await fetch(`${this.API_URL}/languages`);\n            if (response.ok) {\n                this.supportedLanguages = await response.json();\n            }\n        }\n        catch (error) {\n            console.error('Failed to load supported languages:', error);\n            // Fallback to common languages\n            this.supportedLanguages = [\n                { code: 'en', name: 'English' },\n                { code: 'es', name: 'Spanish' },\n                { code: 'fr', name: 'French' },\n                { code: 'de', name: 'German' },\n                { code: 'it', name: 'Italian' },\n                { code: 'pt', name: 'Portuguese' },\n                { code: 'ru', name: 'Russian' },\n                { code: 'zh', name: 'Chinese' },\n                { code: 'ja', name: 'Japanese' }\n            ];\n        }\n    }\n    async translateText(text, targetLanguage) {\n        const response = await fetch(`${this.API_URL}/translate`, {\n            method: 'POST',\n            body: JSON.stringify({\n                q: text,\n                source: 'auto',\n                target: targetLanguage,\n                format: 'text'\n            }),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`Translation API error: ${response.status}`);\n        }\n        const data = await response.json();\n        return {\n            sourceText: text,\n            targetLanguage,\n            translatedText: data.translatedText\n        };\n    }\n    async getSupportedLanguages() {\n        return this.supportedLanguages;\n    }\n}\nexport class FreeDictionaryService {\n    constructor() {\n        this.API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en';\n    }\n    async getDefinition(word) {\n        try {\n            const response = await fetch(`${this.API_URL}/${encodeURIComponent(word)}`);\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null; // Word not found\n                }\n                throw new Error('Dictionary API error');\n            }\n            const data = await response.json();\n            if (!data || !data[0]) {\n                return null;\n            }\n            // Process and format the definition data\n            const result = {\n                word: data[0].word,\n                phonetic: data[0].phonetic || '',\n                meanings: []\n            };\n            // Extract meanings, definitions and examples\n            if (data[0].meanings && data[0].meanings.length > 0) {\n                data[0].meanings.forEach((meaning) => {\n                    const meaningObj = {\n                        partOfSpeech: meaning.partOfSpeech,\n                        definitions: []\n                    };\n                    meaning.definitions.forEach((def) => {\n                        meaningObj.definitions.push({\n                            definition: def.definition,\n                            example: def.example || '',\n                            synonyms: def.synonyms || []\n                        });\n                    });\n                    result.meanings.push(meaningObj);\n                });\n            }\n            return result;\n        }\n        catch (error) {\n            console.error('Error fetching definition:', error);\n            return null;\n        }\n    }\n    getSupportedLanguages() {\n        return ['en']; // Only English is supported\n    }\n}\nexport class IndexedDBStorageService {\n    constructor() {\n        this.DB_NAME = 'vocalearn';\n        this.DB_VERSION = 1;\n        this.STORE_NAME = 'vocabulary';\n    }\n    async initDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onerror = (event) => {\n                reject('IndexedDB error: ' + event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Create object store for vocabulary words\n                if (!db.objectStoreNames.contains(this.STORE_NAME)) {\n                    const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id', autoIncrement: true });\n                    store.createIndex('word', 'word', { unique: false });\n                    store.createIndex('dateAdded', 'dateAdded', { unique: false });\n                }\n            };\n        });\n    }\n    async saveWord(word) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            // Check if word already exists (if it has an ID)\n            const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(this.STORE_NAME);\n            if (word.id) {\n                // Update existing word\n                const updateRequest = store.put(word);\n                updateRequest.onsuccess = () => {\n                    resolve(word);\n                };\n                updateRequest.onerror = () => {\n                    reject(new Error('Error updating word'));\n                };\n            }\n            else {\n                // Check if the word text already exists\n                const wordIndex = store.index('word');\n                const request = wordIndex.getAll(word.word);\n                request.onsuccess = (event) => {\n                    const matches = event.target.result;\n                    if (matches.length > 0) {\n                        // Update existing word\n                        const existingWord = matches[0];\n                        const updatedWord = {\n                            ...existingWord,\n                            translation: word.translation,\n                            notes: word.notes,\n                            lastReviewed: new Date().toISOString()\n                        };\n                        const updateRequest = store.put(updatedWord);\n                        updateRequest.onsuccess = () => {\n                            resolve(updatedWord);\n                        };\n                        updateRequest.onerror = () => {\n                            reject(new Error('Error updating word'));\n                        };\n                    }\n                    else {\n                        // Add new word\n                        const addRequest = store.add(word);\n                        addRequest.onsuccess = (event) => {\n                            const newWord = { ...word, id: event.target.result };\n                            resolve(newWord);\n                        };\n                        addRequest.onerror = () => {\n                            reject(new Error('Error adding word'));\n                        };\n                    }\n                };\n            }\n        });\n    }\n    async getWords() {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readonly');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.getAll();\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Error fetching words'));\n            };\n        });\n    }\n    async getWordById(id) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readonly');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.get(id);\n            request.onsuccess = (event) => {\n                const result = event.target.result;\n                resolve(result || null);\n            };\n            request.onerror = () => {\n                reject(new Error('Error fetching word'));\n            };\n        });\n    }\n    async deleteWord(id) {\n        const db = await this.initDB();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(this.STORE_NAME);\n            const request = store.delete(id);\n            request.onsuccess = () => {\n                resolve(true);\n            };\n            request.onerror = () => {\n                reject(new Error('Error deleting word'));\n            };\n        });\n    }\n    async searchWords(query) {\n        const words = await this.getWords();\n        const lowerQuery = query.toLowerCase();\n        return words.filter(word => word.word.toLowerCase().includes(lowerQuery) ||\n            word.translation.toLowerCase().includes(lowerQuery) ||\n            word.notes.toLowerCase().includes(lowerQuery));\n    }\n}\nexport class LocalStorageCacheService {\n    constructor() {\n        this.PREFIX = 'vocalearn_cache_';\n    }\n    async get(key) {\n        const cacheKey = this.PREFIX + key;\n        const item = localStorage.getItem(cacheKey);\n        if (!item) {\n            return null;\n        }\n        try {\n            const cacheItem = JSON.parse(item);\n            // Check if expired\n            if (cacheItem.expiry && cacheItem.expiry < Date.now()) {\n                localStorage.removeItem(cacheKey);\n                return null;\n            }\n            return cacheItem.value;\n        }\n        catch (error) {\n            console.error('Error parsing cache item:', error);\n            return null;\n        }\n    }\n    async set(key, value, ttlSeconds) {\n        const cacheKey = this.PREFIX + key;\n        const cacheItem = {\n            value\n        };\n        if (ttlSeconds) {\n            cacheItem.expiry = Date.now() + (ttlSeconds * 1000);\n        }\n        localStorage.setItem(cacheKey, JSON.stringify(cacheItem));\n    }\n    async remove(key) {\n        const cacheKey = this.PREFIX + key;\n        localStorage.removeItem(cacheKey);\n    }\n    async clear() {\n        const keysToRemove = [];\n        for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key && key.startsWith(this.PREFIX)) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.forEach(key => localStorage.removeItem(key));\n    }\n}\n","export class LocalStorageCacheService {\n    constructor() {\n        this.PREFIX = 'vocalearn_cache_';\n    }\n    async get(key) {\n        const cacheKey = this.PREFIX + key;\n        const item = localStorage.getItem(cacheKey);\n        if (!item) {\n            return null;\n        }\n        try {\n            const cacheItem = JSON.parse(item);\n            // Check if expired\n            if (cacheItem.expiry && cacheItem.expiry < Date.now()) {\n                localStorage.removeItem(cacheKey);\n                return null;\n            }\n            return cacheItem.value;\n        }\n        catch (error) {\n            console.error('Error parsing cache item:', error);\n            return null;\n        }\n    }\n    async set(key, value, ttlSeconds) {\n        const cacheKey = this.PREFIX + key;\n        const cacheItem = {\n            value\n        };\n        if (ttlSeconds) {\n            cacheItem.expiry = Date.now() + (ttlSeconds * 1000);\n        }\n        localStorage.setItem(cacheKey, JSON.stringify(cacheItem));\n    }\n    async remove(key) {\n        const cacheKey = this.PREFIX + key;\n        localStorage.removeItem(cacheKey);\n    }\n    async clear() {\n        const keysToRemove = [];\n        for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key && key.startsWith(this.PREFIX)) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.forEach(key => localStorage.removeItem(key));\n    }\n}\n","// This polyfill ensures compatibility between Chrome and Firefox extension APIs\n// The 'browser' object is used in Firefox extensions while 'chrome' is used in Chrome extensions\n// Use browser if available (Firefox), otherwise use chrome (Chrome, Edge)\nconst browserAPI = (typeof browser !== 'undefined' ? browser : chrome);\nexport default browserAPI;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// src/background.ts\nimport browserAPI from './utils/browser-polyfill';\nimport { ServiceLocator } from './infra/di/service-locator';\nimport { ConfigurationService } from './infra/services/configuration-service';\nimport { TranslationServiceFactory } from './infra/factories/translation-service-factory';\nexport function setupBackgroundScript() {\n    // Initialize services based on user configuration\n    initializeServices();\n    // Set up context menu\n    browserAPI.runtime.onInstalled.addListener(() => {\n        browserAPI.contextMenus.create({\n            id: 'translate-selection',\n            title: 'Translate \"%s\"',\n            contexts: ['selection']\n        });\n    });\n    // Handle context menu clicks\n    browserAPI.contextMenus.onClicked.addListener((info, tab) => {\n        if (info.menuItemId === 'translate-selection' && info.selectionText && tab?.id) {\n            browserAPI.tabs.sendMessage(tab.id, {\n                action: 'translateSelection',\n                text: info.selectionText\n            });\n        }\n    });\n    // Handle messages from content script\n    browserAPI.runtime.onMessage.addListener((request, sender, sendResponse) => {\n        if (request.action === 'getTranslation') {\n            handleTranslationRequest(request, sendResponse);\n            return true; // Keep the message channel open for the async response\n        }\n        if (request.action === 'saveWord') {\n            handleSaveWordRequest(request, sendResponse);\n            return true; // Keep the message channel open for the async response\n        }\n        return false;\n    });\n}\nasync function initializeServices() {\n    const configService = ConfigurationService.getInstance();\n    const config = await configService.getConfig();\n    // Initialize translation service based on user preference\n    const apiKey = await new Promise(resolve => {\n        browserAPI.storage.local.get(['apiKey'], result => {\n            resolve(result.apiKey);\n        });\n    });\n    TranslationServiceFactory.register(config.translationService, apiKey);\n}\nasync function handleTranslationRequest(request, sendResponse) {\n    try {\n        const configService = ConfigurationService.getInstance();\n        const config = await configService.getConfig();\n        const serviceLocator = ServiceLocator.getInstance();\n        const translateUseCase = serviceLocator.getTranslateTextUseCase();\n        // Get translations\n        const translations = await translateUseCase.execute(request.text, config.targetLanguages);\n        // Get definition if enabled\n        let definition = null;\n        if (config.includeDefinitions) {\n            const getDefinitionUseCase = serviceLocator.getDefinitionUseCase();\n            definition = await getDefinitionUseCase.execute(request.text);\n        }\n        // Send response back to content script\n        sendResponse({\n            translations,\n            definition\n        });\n    }\n    catch (error) {\n        console.error('Error processing translation request:', error);\n        sendResponse({ error: 'Failed to get translation' });\n    }\n}\nasync function handleSaveWordRequest(request, sendResponse) {\n    try {\n        const serviceLocator = ServiceLocator.getInstance();\n        const saveWordUseCase = serviceLocator.getSaveVocabularyWordUseCase();\n        await saveWordUseCase.execute(request.word, request.translation, request.notes || '');\n        sendResponse({ success: true });\n    }\n    catch (error) {\n        console.error('Error saving word:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n}\n// Initialize the background script\nsetupBackgroundScript();\n"],"names":[],"sourceRoot":""}